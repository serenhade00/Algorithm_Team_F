# 💻 허프만 압축 💻


## 프로그램 목적
***

* <mark>입력:</mark> **영문 소설** 또는 **문서**(기사, 칼럼, 등)가 주어진다. 이때 주의해야 할 점은 단순히 내용을 복붙해서 입력창에 직접 써 넣는게 아니라 `.txt`와 같은 파일 자체를 입력으로 받는다.

* 출력: 파일의 내용을 **허프만 압축**을 통해 **허프만 코드**로 변환 후 압축된 내용의 크기와 원래 파일의 크기를 비교하여 **압축률**을 계산해서 출력한다. 

* 압축률은 다음과 같이 정의하였다.  
> 압축률(%): 압축 크기 / 원본 크기 (단위: KB)

<br>

## 프로그램 설명
*** 
  
프로그램은 2개의 파일로 구성되어있다.

* `Huff`라는 이름의 헤더파일
* `main`함수를 포함한 `huffman`이라는 이름의 C++기반 소스 코드 파일

각 파일에 대한 간략한 설명:

* **Huff.h (헤더파일)**
    - 클래스 `Node`: 트리 구조를 만들기 위한 노드 형태 정의
    - 클래스 `Huffman`: 허프만 압축에 필요한 함수 및 변수 정의
* **huffman.cpp (메인 함수 및 소스 코드)** 
    * `Huff.h`에서 만든 기능 사용
    * `main`에서는 `txt`기반 파일을 입력받고 `encoding`, `to_huff`, `size`등 함수들을 실행하며 압축 코드를 얻는다. 그 후 원본 크기와 비교하여 압축률을 계산하고 출력한다.

**<u>각 코드가 어떤 기능을 가지고 무슨 역할을 수행하는지는 소스 코드에 주석을 자세하게 달아놓았으니 참조바란다.</u>**

<br>

## 성능 테스트 & 한계점
***

두번의 테스트를 진행했다. 파일명은 두 파일의 이름을 `test.txt`로 바꿔가며 진행했다.
1. 매우 짧은 파일 (10KB이내)
2. 길이가 조금 더 긴 파일 (대략 100KB)

<br>

>첫째, 영문 기사 7.77KB 크기 파일 (출처: CNN) 

<img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/size_1.jpg?raw=true" width="500" height ="250" />

>둘째, 영어 회화 수업에 사용한 과제 내용(반복) 101.2KB 파일 (출처: ~~본인~~)

<img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/size_2.jpg?raw=true" width="500" height ="250" />

<br>

>실행 결과는 순서대로 다음과 같다.

![test](https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/Test4.jpg?raw=true)
![test1](https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/Test5.jpg?raw=true)

### 일반적 성능 & 시간복잡도 분석

성능도를 분석해보면, 물론 많은 테스트 케이스를 돌려본것은 아니지만 파일 크기에 제한받지 않고 의도한대로 허프만 압축을 잘 실행하는듯 하다. 프로그램에 의한 압축률은 대략 50~60% 정도다. 

1. 파일을 입력받고 문자별 빈도수 갱신
    * 파일을 문장별로 입력받고 `map` 컨테이너에 값을 증가시키므로 O(n)
2. `map`에서 가져온 빈도수를 기준으로 `Node` 생성하여 우선순위큐 생성
    * 우선순위큐에 `push`하는 과정만 존재하므로 O(n)
3. 우선순위큐를 기반으로 허프만 트리 생성
    * 최소 빈도수를 가진 순서대로 `pop`하고 그 합을 또 `Node`로 만들어 `push`하는 과정을 반복하므로, `heap`구조의 특성에 의해 $O(log n)$이 걸린다. 그러나 입력-1(n-1)번 만큼 연산이 반복되므로 총 시간복잡도는 O(nlogn)
4. 허프만 트리에 코드를 부여하는 과정
    * 평균적으로 트리의 높이는 `log n` 정도이다. 왜냐하면 위에서부터 하나의 레벨에서 `pop`할 수 있는 노드의 최대 개수가 2^n(0, 1, 2...) 꼴이기 때문이다. 리프 노드까지 도달해야 코드가 부여되므로 이 역시 n-1 * log n, 즉 O(nlogn) 정도가 걸린다. (사실 매번 새로 부여하는게 아닌 스택에 이미 부여된 값에서 `string`을 더하는 형태니 이것보다는 덜 걸릴것이다)
5. 허프만 코드 return, 압축 크기 계산, 압축률 계산
    * 전부 O(1)

> 총 시간복잡도: O(n) + O(n) + O(nlogn) + O(nlogn) + O(1) = O(nlogn).


### 제한 사항 및 개선점

* 프로그램이 압축을 잘 해내므로 구현이나 알고리즘면에서는 문제가 없는것같다.

* 하지만 이 프로그램에 치명적인 문제가 존재한다. 처음에 의도한 바는 입력 파일을 읽을때 문자열 단위로 한 문장씩 읽어서 각 문자의 빈도수를 갱신하는거였다. 그러나 여러 테스트를 거쳐본 뒤 `txt`파일이 하나의 이어진 문자열이 아니면 프로그램이 제대로 입력을 가져오지 못한다. 

* 즉, 문장 하나하나를 잘 읽어오긴 하지만 파일 중간에 문단을 바꾼다던지 하는 큰 공백이 있으면 이를 파일의 끝으로 인식하고 나머지를 공백으로 채워버린다. 따라서 파일을 문단 변경없이 문장들이 바로바로 이어지도록 조정해야 프로그램이 의도대로 돌아간다. 이는 확실히 교수님께서 제시하셨던 영문 소설(문단 o)등을 입력으로 받는것과는 차이가 있다. 다른 코드는 다 좋은데 이 부분이 좀 아쉽다.

<br>

<p align="center">Copyrightⓒ. 2022. By Team F (201901685 신성환, 201901659 김동현, 202101629 이지훈). </p>
<p align="center">All Rights Reserved.</p>
<p align="center">-The End-</p>















